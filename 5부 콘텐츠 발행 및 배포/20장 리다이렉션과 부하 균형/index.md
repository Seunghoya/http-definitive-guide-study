HTTP 메시지의 데이터는 여정 중에 많은 프로토콜에 의해 통제된다. HTTP 메시지의 목적지는 미러링된 서버,프록시,캐시 등 다양하다.
<b>리다이렉션 기술</b>은 이런 여러 목적지 중 어디에서 메시지가 끝나는지 판별하기 위해 사용한다. 클라이언트가 명시적으로 요청하지 않은 곳으로 메시지를 보낼 수 있다.

### 20.1 왜 리다이렉트인가?
- 신뢰할 수 있는 HTTP 트랜잭션의 수행, 지연 최소화, 네트워크 대역폭 절약을 위해 리다이렉션은 현대 웹에서 피할 수 없는 현실이다.
- 웹 콘텐츠는 흔히 여러 장소에 배포되며, 한 곳에서 요청이 실패한 경우 다른 곳을 이용할 수 있으므로 신뢰성이 개선된다.
- 클라이언트에서 보다 가까운 리소스에 접근해 응답 지연을 줄인다.
- 목적지 서버가 분산되므로 네트워크 혼잡도가 줄어든다.
리다이렉션의 구현에는 부하 균형(로드 밸런싱)의 과제가 포함된다. 
- 리다이렉션을 통해 들어오는 메시지의 부하를 서버 집합에 분산시키고, 부하 균형의 과정에서는 반드시 부하를 공유하는 서버와 리다이렉션을 통해 메시지를 전달하기 때문이다.

### 20.2 리다이렉트 할 곳
클라이언트 관점에서 서버,프록시,캐시,게이트웨이는 모두 서버의 특성을 가지고 있으므로, 많은 리다이렉션 기법이 이 모두에서 동작한다.
웹서버 : IP별로 요청을 다룬다. 같은 URL에 대해 여러 곳에서 온 요청들을 최적의 웹서버로 보내 요청을 분산한다.
프록시 : 프로토콜별로 요청을 다룬다. 프록시 이웃의 모든 HTTP는 프록시를 거쳐야 한다. 클라이언트 근처의 프록시 캐시가 있다면 모든 요청이 프록시 캐시로 흘러들어가는 것이 이상적이다. 캐시가 자주 찾는 문서를 저장해 클라이언트에 제공하기 때문에 이렇게 해야 원서버로의 오래 걸리고 비용이 큰 통신을 피할 수 있기 때문이다.

### 20.3 리다이렉션 프로토콜의 개요
리다이렉션의 목표는 HTTP 메시지를 가용한 웹서버로 가급적 빨리 보내는 것이다. 
HTTP 메시지가 인터넷을 통해 나아가는 방향은 향하는 HTTP 애플리케이션과 라우팅 장치에 영향을 받는다.
- ex) 브라우저 설정(프록시로 향하는 트래픽만 설정 가능), DNS, TCP/IP 라우팅, 웹서버 HTTP 리다이렉트(보내려는 곳에 상관없이 사용 가능)

### 20.4 일반적인 리다이렉션 방법
#### 20.4.1 HTTP 리다이렉션
웹서버는 다른 곳으로 요청을 보내라고 말해주는 짧은 리다이렉트 메시지를 클라이언트에게 돌려줄 수 있다. 이를 통해 간단히 부하를 분산한다.
- 요청을 처리하는 리다이렉팅 서버는 가용한 서버중 부하가 가장 적은 콘텐츠 서버를 찾아 브라우저 요청을 리다이렉트한다. 이때 웹서버가 광법위하게 분산되어 있다면 '최성의' 가용 서버를 결정하는 것은 어려워진다. 
서버의 부하 뿐 아니라 브라우저-서버간의 거리 또한 계산해야하기 때문이다.
- 다른 형태보다 HTTP 리다이렉션이 가지는 장점은 : 클라이언트의 IP를 알고 있다는 것이다. 이론적으로, 이렇게 하면 좀 더 정보에 근거해 선택할 수 있다.
- 단점은 : 
1) 서버로 향하는 요청의 방향은 변경할 수 있지만, 어떤 서버로 리다이렉트할지 결정하려면 원 서버가 상당히 많은 처리를 해야한다. 이는 거의 페이지 자체를 제공할 때와 거의 같은 양의 처리가 필요하다. 
2) 페이지에 접근할 때마다 두 번의 왕복 트랜잭션이 필요하기 때문에 사용자가 더 오래 기다린다.
3) 만약 리다이렉트 서버가 고장나면 사이트도 고장난다.

#### 20.4.2 DNS 리다이렉션
클라이언트가 사이트에 접근하려고 시도할 때마다, 도메인 이름은 반드시 IP주소로 분석되어야 한다.
DNS 분석자(리졸버)는 클라이언트 운영체제, 클라이언트 네트워크에 있는 DNS서버, 더 원격에 있는 DNS 서버일 수도 있다. 
DNS는 하나의 도메인에 여러 IP주소가 결부되는 것을 허용하며, DNS 분석자(리졸버)는 어떤 IP주소를 반활할지 결정하는데, 단순한 라운드 로빈부터 복잡한 것까지 다양하다.
- DNS 라운드 로빈 : 가장 단순한 리다이렉션 기법. 
   - 특정 도메인의 사이트는 실제로 여러개의 구분된 IP주소의 농장(farm)이다. 
   - 대부분의 DNS클라이언트는 그냥 다중 주소 집합의 첫번째 주소를 사용하며, 
   - 부하 균형을 위해 DNS서버는 DNS룩업이 끝났을 때마다 주소를 순환시킨다. 
   - 만약 DNS가 주소를 순환시키지 않으면 대부분 첫번째 주소를 선택할 것이고, 그 서버가 대부분의 부하를 받게 된다.
   - 하지만, 이 부하 균형은 완벽하지 않은데, DNS룩업의 결과는 앱, 운영체제, 몇몇 기본 자식 DNS서버에 의해 기억되어 재사용될 수 잇기 떄문이다.
   - (이유 : 호스트 하나에 대해 한번의 룩업 수행 후 재사용해 룩업 비용을 줄이고, 같은 클라이언트와 계속 대화하는 것을 선호하는 서버도 있기 때문)
   - 단일 클라이언트의 트랜잭션을 분산하지 않더라도, 여러 클라이언트의 부하 총량을 분산하는 적절한 작업을 수행한다.
부하 균형 알고리즘 : 웹서버의 로드를 추적해 가장 로드가 적은 웹서버를 목록의 가장 위에 놓는다.
근접 라우팅 알고리즘 : 지리적으로 분산되어 있는 경우 클라이언트의 근처 웹서버로 보낸다.
결함 마스킹 알고리즘 : 네트워크 헬스 체크를 통해 정전이나 기타 장애를 피해 라우팅 한다.
<img width="521" alt="dns requests resolving by authoritative server" src="https://user-images.githubusercontent.com/54028005/211201074-9932b6fc-ab20-4017-9b03-25fbc4791299.png">
단점 : auth 서버가 결정을 내리기 위해 사용하는 유일한 정보가 클라이언트의 IP주소가 아닌 로컬DNS 서버의 IP주소라는 점.

#### 20.4.3 임의 캐스트 어드레싱
지리적으로 흩어진 웹서버들은 정확히 같은 IP주소를 갖고 클라이언트의 요청을 클라이언트의 가장 가까운 서버로 보내주기 위해 백본라우터의 '최단거리' 라우팅 능력에 의지한다.
이 방법이 동작하는 방식은 각 웹서버에 자신을 인접한 백본라우터를 향하는 라우터라고 광고하는 것이다.
- 웹서버는 라우터 통신 프로토콜을 이용해 자신과 인접한 백본라우터와 대화한다.
- 백본라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받았을 때, 그 IP주소를 받아들일 수 있는 가장 가까운 라우터를 찾는다.
- 그 서버는 자신이 그 주소를 받아들일 수 있는 가장 가까운 라우터라고 광고한 상태일 것이기 때문에, 그 백본라우터는 그 서버에게 패킷을 보낼 것이다.
- 서버는 반드시 라우터의 언어로 말해야하고, 라우팅 누수를 막기 위해 주소 충돌을 반드시 다룰 수 있어야 한다.
<img width="517" alt="cast addressing" src="https://user-images.githubusercontent.com/54028005/211201517-ae359b00-cad8-4fa1-b29e-ec5e5f3d1fc5.png">

#### 20.4.4 IP MAC 포워딩
이더넷 네트워크에서, HTTP 메시지는 주소가 붙은 데이터 패킷의 형태로 보내진다. 
각 패킷은 출발/목적지의 IP주소와 TCP포트번호로 이루어진 Layer4주소와, (L2)스위치나 허브가 주의를 기울여야하는 Layer2주소인 MAC주소를 가지고 있다.

<img width="507" alt="layer2 switch, route to gw" src="https://user-images.githubusercontent.com/54028005/211201757-cceb1282-6dbc-4b6e-aa6a-11d42d6070db.png">

<img width="531" alt="L4switch MAC forwarding" src="https://user-images.githubusercontent.com/54028005/211202064-6813507e-f98f-49de-a113-3a90cb757be9.png">ㅣ

MAC 포워딩을 지원하는 L4스위치는 보통 특정 포트(ex.80)로 들어오는 요청을 여러 프록시(ex.캐시)로 보낼 수 있다. 
단, MAC 포워딩은 홉바이홉으로만 가능하기 때문에 서버나 프록시가 스위치와 한 홉 거리에 위치해야 한다.

#### 20.4.5 IP 주소 포워딩

IP 주소 포워딩에서는 L4장비들이 MAC주소가 아니라 목적지 IP주소의 변경에 따라 라우팅한다. 
MAC 포워딩과 달리 목적지 서버가 한 홉거리에 있을 필요가 없다는 장점이 있다.
스위치에서 업스트림의 위치를 판별할 수만 있으면 L3 인터넷 라우팅이 패킷을 올바른 위치로 보내준다.
이런 전달을 네트워크 주소 변환(NAT)라고도 부른다.
단, 라우팅 대칭성이라는 문제가 있다. 
- 클라이언트로부터 들어오는 TCP커넥션을 받아주는 스위치는 그 커넥션을 관리하고 있고, 반드시 그 커넥션을 통해 클라이언트에게 응답을 돌려주어야 한다.

<img width="533" alt="ip forwarding switch" src="https://user-images.githubusercontent.com/54028005/211202492-caffd3ef-afa7-4acc-b7e7-e5e16dfec859.png">

응답의 귀환 경로를 제어할 수 있는 두 가지 방법 : 
1) 패킷의 출발지 IP주소를 스위치의 IP주소로 바꾼다. 
이 방법은 스위치와 서버 사이의 네트워크 설정이 어떤가와는 관계 없이 응답 패킷을 스위치로 가게 한다.
출발/목적지 IP주소 양쪽을 번역해주는 IP전달장치를 <b>완전NAT</b>라고 한다.
그 결과, 인증이나 결제를 위해 필요할 수도 있는 클라이언트 IP주소를 웹서버가 알 수 없게 된다.
2) 만약 출발지 IP주소가 그 클라이언트 IP주소로 그대로 계속 남아있다면, 
서버에서 클라이언트로 스위치를 거치지 않고 바로 가는 경로가 존재하지 않아야 한다. 이를 <b>halfNAT</b>라고 부른다.
여기서 장점은 서버가 클라이언트 IP주소를 얻는다는 것이고, 단점은 클라이언트-서버 사이의 네트워크에 약간의 통제가 필요하다는 것이다.

#### 20.4.6 네트워크 구성요소 제어 프로토콜(NECP)
IP패킷을 전달하는 라우터/스위치 같은 네트워크 구성요소(NE)들이 웹서버/프록시 캐시와 같은 애플리케이션 계층 요청을 처리하는 서버 구성요소(SE)와 대화할 수 있게 해준다.
SE는 NE에게 부하 균형 정보를 제공할 수 있는 방법을 제공하여, SE가 적합하다고 판단한 대로 NE가 부하 균형을 유지할 수 있도록 한다.

### 20.5 프락시 리다이렉션 방법

- 일반적인 리다이렉션은 프락시를 통하거나 네트워크에 있는 프락시 캐시를 이용한다.
- 웹브라우저와 같은 클라이언트가 프락시로 가는 길을 아는 방법 3가지
  - 명시적인 브라우저 설정
  - 동적인 자동 설정
  - 자연스러운 가로채기
- 프락시는 클라이언트의 요청을 다른 프락시로 리다이렉트 할 수 있다.

#### 20.5.1 명시적 브라우저 설정

- 브라우저에는 프락시 서버에 접촉하기 위해 프락시 이름, 아이피 주소, 포트번호를 설정할 수 있는 풀다운 메뉴가 존재한다.
- 미리 설정되어있는 브라우저들은 프락시와 접촉하는 주소를 알고 있다.
- 명시적인 브라우저 설정의 단점
  - 프락시를 사용하도록 설정된 브라우저들은 프락시가 잘못되었을 경우 원 서버와 접촉하지 않아 이용자는 접속 문제를 경험한다.
  - 네트워크 아키텍처를 변경했을 때 모든 사용자들에게 변경사항을 전파하는 것이 어렵다.

#### 20.5.2 프락시 자동 설정

- 올바른 프락시 서버에 접촉하기 위해 브라우저가 동적으로 자신을 설정할 수 있게 하는 자동 설정 방법은 네트워크 아키텍처 변화로 인한 문제를 해결한다.
- 프락시 자동설정(PAC, Proxy Auto-configuration) 프로토콜
  - 넷스케이프 사에 의해 정의되었고, 거의 모든 브라우저가 지원한다.
  - 브라우저들이 URL별로 접촉해야 할 프락시를 지정한 PAC 파일이라 부르는 특별한 파일을 찾도록 한다. 브라우저는 PAC 파일을 얻기 위해 지정된 서버에 접촉하도록 설정되어야 하고, 재시작할 때마다 PAC 파일을 가져온다.
  - PAC 파일은 `function FindProxyForURL(url, host)` 함수를 반드시 정의해야하는 자바스크립트 파일이다.
  - 브라우저는 요청된 URL마다 `return_value = FindProxyForURL(url_of_request, host_in_url)` 함수를 호출
  - 프락시의 위치가 변경된 경우 이를 반영하기 위해 PAC 파일이 서버에서 업데이트되기 대문에 PAC는 브라우저가 자동으로 네트워크 아키텍처 안에서의 변경에 맞는 올바른 프락시에 접촉할 수 있도록 해줄 수 있다.
    ![프락시 자동 설정](https://user-images.githubusercontent.com/74203440/211302308-d7a20f98-1311-4711-9ac8-370d7fb4c9aa.jpeg)

#### 20.5.3 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol)

**PAC 파일 자동발견**

- WPAD는 HTTP클라이언트가 PAC파일 위치를 알아내고 PAC파일을 이용하여 적절한 프락시 서버의 이름을 알아낼 수 있게 한다.
- WPAD 프로토콜은 설정 URL(CURL)이라고 알려진 PAC파일 URL 발견하고, 적절한 프락시 서버의 주소를 반환하는 자바스크립트 프로그램을 실행한다.

**WPAD 알고리즘**

- WPAD는 적절한 PAC 파일 CURL을 결정하기 위해 여러 리소스 발견 기법들을 사용한다.
- WPAD 클라이언트에게는 오직 DHCP와 DNS에게 알려진 호스트 명 기법만 요구된다.
- WPAD 클라이언트는 앞에서 언급한 발견 메커니즘을 이용해서 리소스 발견 요청을 순서대로 보낸다. 발견 시도가 성공할 때마다, 클라이언트는 PAC CURL을 생성하기 위해 취득한 정보를 사용한다.
- PAC파일이 CURL에서 성공적으로 발견되면 과정은 완료된다.
- 모든 메커니즘을 시도한 후에도 PAC파일을 찾지 못하면 WPAD 프로토콜은 실패하고 클라이언트는 프락시 서버를 사용하지 않는 것으로 설정된다.

**DHCP를 이용한 CURL 발견**

- WPAD 클라이언트가 질의하는 DHCP 서버는 반드시 CURL을 저장하고 있어야 한다.
- WPAD 클라이언트는 DHCP 질의를 DHCP 서버에 보냄으로써 CURL을 얻는다.
- WPAD 클라이언트가 자신의 초기화 과정에서 이미 DHCP 질의를 했다면 DHCP 서버는 이미 그 값을 제공했을 수도 있다.
- WPAD를 위한 DHCP 옵션 코드 252는 임의의 길이의 문자열이고, 적절한 PAC파일을 가리키는 URL을 포함한다.
  ex) `http://server.domain/proxyconfig.pac`

**DNS A 레코드 룩업**

- 이 메커니즘이 동작하려면, 알맞는 프락시 서버의 IP주소들이 WPAD 클라이언트들이 질의할 수 있는 DNS 서버에 반드시 저장되어 있어야 한다.
- WPAD 클라이언트는 A레코드 룩업을 DNS 서버로 보내 CURL을 얻는다.
- 룩업이 성공하면 적절한 프락시 서버의 IP주소를 얻는다.

**PAC 파일 가져오기**

- 한번 후보 CURL이 생성되면, WPAD 클라이언트는 보통 그 CURL로 GET요청을 만드는데, 이때 자신이 다룰 수 있는 적절한 CFILE 포맷 정보가 담긴 Accept 헤더를 포함해야 한다.
  ex) `Accept: application/x-ns-proxy-autoconfig`
- CURL 결과가 리다이렉트라면, 그곳이 클라이언트의 최종 목적지이다.

**언제 WPAD를 실행하는가**

- 웹 클라이언트가 시작될 때와 클라이언트 호스트의 아이피 주소가 변경된 네트워킹 스택으로부터 어떤 언급이 있을 때마다 WPAD가 실행된다.
- PAC 파일이 만료되면 클라이언트는 WPAD프로세스를 재시작해야한다.
- PAC 파일이 대체품을 제공하지 않고 현재 설정된 프락시가 동작하지 않으면 WPAD 프로세스를 재실행하도록 구현할 수 있다.
- 클라이언트가 현재 PAC 파일을 무효화 하기로 했다면, 최신의 올바른 CURL을 가져오는 것을 보장하기 위해 반드시 전체 WPAD 프로토콜을 재실행해야 한다.

**WPAD 스푸핑(spoofing)**

- WPAD의 IE5구현은 사용자의 개입 없이 웹 클라이언트가 프락시 설정을 자동으로 탐지하는 것을 가능하게 했다. WPAD 알고리즘은 호스트 명 'wpad'를 도메인 이름의 절대 표기 앞에 붙이고 WPAD 서버를 찾아내거나 3차 도메인에 도달할 때까지 계속해서 서브도메인을 지운다.

**타임아웃**

- 여러 발견 단계를 거치게 되며, 클라이언트는 각 단계가 일정한 시간 내에 끝나는지 반드시 확인해야 한다.



### 20.6 캐시 리다이렉션 방법
마지막 절은 캐싱 프락시 서버를 위해 사용되는 보다 복잡한 리다이렉션 기법 중 몇 가지에 대해 설명한다.

**신뢰성 높고, 고성능에, 콘텐츠 지각 디스패칭(content-aware-dispathching)** 까지 가능하게 하기 위해 앞서 이야기 한 프로토콜보다 훨씬 더 복잡하다.

#### 20.6.1 WCCP 리다이렉션
- 시스코 시스템즈는 웹 라우터들이 웹 트래픽을 프락시 캐시로 리다이렉트 할 수 있도록 하기 위해 **캐시 조직 프로토콜(WCCP, Web Cache Communication Protocol)** 을 개발했다. 
- WCCP는 라우터들과 캐시들 사이의 대화를 관리하여 라우터가 캐시를 검사하고(실행되어 있고 동작 중임을), 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게 해준다.

**WCCP 리다이렉션 동작**
-  WCCP를 사용할 수 있는 라우터와, 다른 캐시와 의사소통 할 수 있는 캐시가 포함된 네트워크가 필요.
- 라우터들의 집합과 그들의 대상이 되는 캐시들이 WCCP 서비스 그룹을 구성한다.
	- 서비스 그룹의 설정은 어떤 트래픽이 어디로 어떻게 보내지는지, 그리고 서비스 그룹에서 부하가 캐시들 사이에서 어떻게 분산되어야 하는지 명시
- 서비스 그룹이 HTTP 트래픽을 리다이렉션하도록 설정되어 있으면 서비스 그룹의 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보낸다.
- 서비스 그룹 라우터는 HTTP 요청을 아이피 주소의 해시나 마스크/값 집합 대조 스킴 중 하나에 근거하여 서비스 그룹의 캐시를 선택한다.
- 라우터는 요청 패킷을 캐시의 아이피 주소와 함께 캡슐화하거나 아이피 맥 포워딩하여 캐시로 보낸다.
- 캐시가 요청을 처리할 수 없으면 패킷은 라우터로 돌아온다.
- 서비스 그룹의 구성원들은 지속적인 하트비트 메시지(정상동작 중임을 알려주는)를 교환한다.

**WCCP2 메시지들**
<img width="500" alt="WCCP2 메시지" src="https://user-images.githubusercontent.com/87509645/212659637-a8f3de03-ff3e-46d0-83a1-f5b3e217c111.png">


**메시지 구성요소**

- 각 WCCP2 메시지는 헤더와 구성요소로 구성되어 있다.
- 헤더 정보는 메시지의 종류(Here I Am, I See You, Assignment, Removal Query), WCCP 버전, 메시지의 길이를 포함한다.
<img width="500" alt="" src="https://user-images.githubusercontent.com/87509645/212663927-2d58c17c-2b5f-4bad-a12d-8f5d973995cd.png">

**서비스 그룹**
- 서비스 그룹은 WCCP를 지원하는, WCCP 메시지를 교환할 수 있는 라우터와 캐시들의 집합으로 구성되어 있다.
- 라우터들은 웹 트래픽을 서비스 그룹의 캐시로 보낸다.
- 서비스 그룹의 설정은 어떻게 트래픽이 서비스 그룹의 캐시들로 분산되는지 결정한다.
- 라우터와 캐시는 Here I Am과 I See You 메시지를 이용해 서비스 그룹 설정 정보를 교환한다.

**GRE 패킷 캡슐화**
- WCCP를 지원하는 라우터들은 HTTP 패킷을 특정 서버의 IP 주소와 함께 캡슐화함으로써 그 서버로 리다이렉트 한다.
- 일반 라우터 캡슐화(Generic Router Encapsulation, GRE)임을 나타내는 IP 헤더 proto 필드도 포함한다.

**WCCP 부하 균형**
- 라우터들과 서버들은 그들이 살아있고 동작중임을 알 수 있도록 지속적으로 하트비트 메세지를 서로 교환한다.
- 가용불가로 판단되면 WCCP 라우터는 트래픽을 리다이렉트하지 않고 인터넷으로 바로 보낸다.
- 다시 정상화되면 WCCP 라우터는 다시 하트비트 메시지를 받고 그 노드로 요청 트래픽을 보낸다.