※ 16장 국제화에서 배우게 될 내용들

- HTTP는 여러 언어와 문자로 된 국제 문서들의 처리 및 전송 지원
- 2가지 주요 국제화(Internationalization) 이슈
  - 문자집합 인코딩: 여러 언어의 문자 텍스트를 요청하고 보여주기 위해 사용
  - 언어 태그: 사용자가 이해할 수 있는 언어로 컨텐츠를 서술하기 위해 사용
  - \+ 여러 언어로 된 URI 및 날짜에 대해서도 다룰 것

<br>

## 1. 국제적인 컨텐츠를 다루기 위해 필요한 HTTP 지원

- HTTP에서 엔티티 본문이란 그저 bit들로 가득 찬 상자에 불과
  - 그렇기 때문에 어떤 언어로 된 컨텐츠, 이미지, 동영상 등을 미디어처럼 실어 나를 수 있는 것
- 국제 컨텐츠 지원을 위해,
  - 서버는 클라이언트에게 각 문서의 문자와 언어를 알려줘야 함
  - 클라이언트는 문서를 이루고 있는 bit들을 문자들로 풀어내고, 올바르게 처리해서 사용자에게 컨텐츠를 제공해줘야 함
- 서버가 문서의 문자와 언어를 알려주는 방법 :
  - Content-Type 헤더의 `charset` 메게변수와, Content-Language 헤더 활용
  - 이 헤더들의 역할 :
    - _엔티티 본문의 'bit들로 가득 찬 상자'에 무엇이 들어있는지_
    - 어떻게 컨텐츠를 화면에 출력할 올바른 글자들로 바꿀 수 있는지
    - 텍스트가 어떤 언어에 해당하는지
- 클라이언트는 본인이 어떤 언어를 이해할 수 있고, 어떤 Charset 인코딩 알고리듬이 브라우저에 설치되어 있는지 말해줄 필요가 있음
  - Accept-Charset 헤더와 Accept-Language 헤더 활용

```http
Accept-Language: fr, en;q=0.8
Accept-Charset: iso-8859-1, utf-8
```

<br>

## 2. 문자집합과 HTTP

국제 알파벳 스크립트, 문자집합 인코딩 → 웹 국제화에서 가장 중요하고 가장 헷갈리는 부분!

### 2.1 Charset은 글자를 bit로 변환하는 인코딩이다

- HTTP Charset = 어떻게 엔티티 컨텐츠의 bit들을 특정 문자 체계의 글자들로 바꾸는지 말해줌
- 각 charset 태그 = bit들을 글자로 변환하거나, 혹은 그 반대 작업을 하기 위한 알고리듬 명명
  - MIME 문자집합에 표준화되어 있고, IANA가 관리

![iso-8859-6 디코딩](https://user-images.githubusercontent.com/75058239/209419101-2c4ebf83-e882-488d-84f1-8c10885f1f20.png)

- 8bit로 256개의 유일한 값을 제공할 수 있음
  - 그러나 UTF-8이나 iso-2022-jp 같은 몇몇 문자 인코딩은 글자 당 bit 수가 일정하지 않음
    - 이런 경우 추가적인 bit를 사용할 수 있게 지원

### 2.2 문자집합과 인코딩은 어떻게 동작하는가

![bit를 문자로 변환하는 과정](https://user-images.githubusercontent.com/75058239/209419113-32b96973-212e-459b-9510-804bde36d671.png)

- **국제화된 문자 시스템의 핵심 목표: 시각적 표현 방식과 글자들의 의미를 분리하는 것!**
  - HTTP는 문자 데이터 및 관련 언어와, charset 라벨 전송에만 관심을 둠
  - 글자의 모양을 어떻게 표현할지는 사용자의 그래픽 디스플레이 소프트웨어(브라우저, 운영체제, 글꼴)가 결정

### 2.3 잘못된 Charset은 잘못된 글자들을 낳는다

- 잘못된 charset 매개변수를 사용하면 클라이언트는 깨진 글자를 보여주게 됨
- charset 값이 225(이진수 11100001)일 때 문자 코드별 인코딩 방식
  - iso-8859-1 서유럽 문자코드 (a): á
  - iso-8859-6 아랍 코드 (FEH): ف
  - iso-8859-7 그리스어 코드 (Alpha): α
  - iso-8859-8 히브리어 코드 (BET): ב

### 2.4 표준화된 MIME Charset 값

MIME Charset: 특정 문자 인코딩과 특정 코딩된 문자집합의 결합

- HTTP는 표준화된 MIME Charset 태그를 Content-Type과 Accept-Charset 헤더에 사용
- MIME Charset 값은 IANA에 등록되어 있음

※ 몇몇 MIME Charset 인코딩 구조들

us-ascii

- 'American Standard Code for Information Interchange'
- 1968년에 ANSI_X3.4-1968로 표준화된 유명한 문자 인코딩
- ASCII라고도 불리지만, 여러 국제 변형이 있었기 때문에 'US'라는 접두어 붙이기를 선호
- 7 bit 값을 128가지 글자에 대응시킴
  - 1 byte(8 bit)에서 나머지 1 bit는 Parity Bit으로서, 통신 에러를 검출하기 위한 용도로 사용됨
- high bit는 사용되지 않음

iso-8859-1

- 서유럽 언어를 지원하기 위한 ASCII의 8 bit 확장
- 0-127 부분에 ASCII 코드를 온전히 유지한 채로 여러 서유럽 글자들을 포함
- iso-latin-1로도 불리며, 'Latin1'이라는 별명도 있음

iso-8859-2

- 체코어, 폴란드어, 루마니아어 같은 중부유럽 혹은 동유럽 언어에서 사용되는 문자들을 포함하기 위해 ASCII를 확장
- iso-latin-2라고도 불림

iso-8859-5

- 러시아어, 세르비아어, 불가리아어 등에 사용되는 키릴 문자를 포함하기 위해 ASCII를 확장

iso-8859-6

- 아랍 문자들을 포함하기 위해 ASCII를 확장
- 글자들의 모양이 단어 내에서의 위치와 연관되기 때문에 이에 따른 디스플레이 엔진도 필요

iso-8859-7

- 현대 그리스 문자를 포함하기 위해 ASCII를 확장
- 이전에는 ELOT-928이나 ECMA-118:1986으로 알려져 있었음

iso-8859-8

- 히브리어와 이디시어 문자들을 포함하기 위해 ASCII 확장

iso-8859-15

- iso-8859-1에서 잘 안 쓰이는 구두점 및 분수 기호들을 빼고, 고대 프랑스어와 핀란드어 글자들을 넣었음
- 국제 통화 기호를 유로 통화 기호로 대체하기 위해 갱신한 것
- 이 문자집합에는 'Latin0'이라는 별명이 있음

iso-2022-jp

- 일본어 전자우편 및 웹 컨텐츠를 위해 널리 사용되는 인코딩
- ASCII 문자들을 지원하는 1 byte로 된 가변길이 인코딩 구조이지만,<br>3가지의 일본어 문자집합으로 전환하기 위해 3글자로 된 modal escape sequence 사용

euc-jp

- ISO 2022 호환 가변길이 인코딩
  - 여러 종류의 모드나 escape 문자열 없이 각 글자를 식별하기 위해 명시적 bit 패턴 사용
- 일본어 문자집합에서 글자 식별을 위해 1byte, 2byte, 3byte 문자열 사용

Shift-JIS

- MS에 의해 개발되었고, 때떄로 SJIS나 MS Kanji라고도 불림
- 역사적인 호환성 문제 때문에 약간 복잡하며 모든 문자에 대응하지도 못하지만 여전히 흔하게 쓰이고 있음

koi8-r

- IETF RFC 1489로 정의된, 러시아어를 위한 인기 있는 8 bit 인터넷 문자집합 인코딩
- 'Code for Information Exchange, 8 bit, Russian'

utf-8

- 전 세계의 문자들에 대해 보편적 문자집합 UCS를 표현하기 위해 흔하게 사용되는 가변길이 문자 인코딩 구조
- 각 글자를 1 ~ 6 byte로 표현하는 가변길이 인코딩을 문자 코드 값에 사용
- 주요 기능 중 하나는 통상적인 7 bit ASCII 문자열에 대한 하위호환성

windows-1252

- 윈도우 코드 페이지 1252
  - MS는 자신들의 코딩된 문자집합을 '코드 페이지'라고 부름
- CP1252 혹은 WinLatin1이라고도 불림
- iso-8859-1의 확장

### 2.5 Content-Type charset 헤더와 META 태그

```http
Content-Type: text/html; charset=iso-2022-jp
```

- 서버는 클라이언트에게 MIME charset 태그를 `charset` 매개변수와 함께 Content-Type 헤더에 담아서 보냄
- 만약 문자집합이 명시되어 있지 않은 경우, 수신자는 컨텐츠로부터 문자집합 추측을 시도
  - HTML 컨텐츠에서는 `<meta http-equiv="Content-Type">` 태그에서 찾을 수 있음

```html
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp" />
  <meta lang="jp" />
  <title>A Japanese Document</title>
</head>
```

- 만약 그래도 클라이언트가 문자 인코딩을 추측할 수 없다면, iso-8859-1인 것으로 가정

### 2.6 Accept-Charset 헤더

- 세상에는 수십 년간 개발되어 온 수천 가지 문자 인코딩 및 디코딩 방법이 있고, 클라이언트가 이 모든 걸 알 수는 없음
- HTTP 클라이언트는 어떤 문자 체계를 지원할 수 있는지를 **Accept-Charset** 요청 헤더를 통해 알려줌
  - 헤더의 값: 클라이언트가 지원하는 문자 인코딩 목록

```http
Accept-Charset: iso-8859-1, utf-8
```

- Accept-Charset 요청 헤더에 대응하는 Content-Charset 응답 헤더는 존재하지 않음
- 응답 문자집합은 MIME와의 호환을 위해 Content-Type 응답 헤더의 `charset` 매개변수를 통해 전달
  - 아쉽게도 대칭적인 구조는 아니지만, 필요한 건 다 받는 셈

<br>

## 3. 다중언어와 문자 인코딩에 대한 지침

문자 체계와 표준에 대한 개관

### 3.1 문자집합 용어

**문자**

- 알파벳, 글자, 숫자, 구두점, 표의문자(중국어 같은), 기호 등 글쓰기의 최소 단위
- UCS(Universal Character Set) 계획에 따라<br>여러 언어의 여러 글자에 알맞는 유일한 이름을 부여하기 위해 표준화된 이름 집합이 개발되어 왔음
  - 약식으로 Unicode라고도 불림
  - 'LATIN CAPITAL LETTER S'나 'ARABIC LETTER QAF' 같은 고유 이름들을 정의

**glyph**

- 하나의 글자를 표현하기 위한, 획 패턴 등과 구분되는 유일한 시각적 형태
- 하나의 글자를 여러 방식으로 쓸 수 있다면, glyph를 여러 개 가질 수도 있음

**coded character**

- 각 글자에 할당된 유일한 숫자 값

**coding space**

- 문자 코드 값으로 사용하기 위해 계획해 둔 정수의 범위

**code width**

- 각 문자 코드의 고정된 크기의 bit 개수

**character repertoire**

- 작업하고자 하는 특정 문자 집합
- 세상에 존재하는 모든 글자에 대한 부분집합

**coded character set**

- character repertoire를 받아서 각 글자 coding space에 코드를 할당해준 코딩된 문자들의 집합
- 쉽게 말해서, 실제 글자들에 숫자로 된 문자 코드를 대응시킨 것

**문자 인코딩 구조**

- 숫자로 된 문자 코드들을 bit의 연속으로 인코딩하고 디코딩할 수 있는 알고리듬
- 글자 식별을 위해 데이터를 압축하거나, 전송상의 제약을 회피하거나, 중복된 coded character set을 통합하는데 사용될 수 있음

### 3.2 'Charset'은 형편없는 이름이다

- 엄밀히 말해, MIME charset 태그는 문자집합을 의미하는 것이 결코 아님
  - 데이터 bit를 고유한 문자의 코드로 매핑하는 알고리듬
  - 문자 인코딩 구조와 coded character set의 개념을 합친 것
- RFC 2616에서 HTTP/1.1의 저자들이 용어를 잘못 사용하면서 표준이 되어버렸음
  - IETF는 RFC 2277에서 이 비표준 용어를 받아들였음

### 3.3 문자

- 쓰기의 기본적 구성요소
- 하나의 문자는 하나의 알파벳 글자, 숫자, 구두점, 표의문자(중국어 같은), 수학 기호 등을 표현
- 글꼴 및 스타일에 독립적

### 3.4 glyphs, ligatures, 표현 형태

- glyph: 각 글자를 그리는 특정한 방법
  - 각 문자는 미적인 양식과 스크립트에 따라 여러 glyph를 가짐

![glyph of an a](https://user-images.githubusercontent.com/75058239/209419128-16aee41c-5777-4a9e-8241-a4b2c10b1807.png)

- ligature: 필기체와 활자체가 인접한 글자들을 부드럽게 이어주는 것

![Ligatures](https://user-images.githubusercontent.com/75058239/209419132-88098917-56d5-438d-9147-258b1514b584.png)

### 3.5 Coded Character Set

![iso-8859-1 coded character set](https://user-images.githubusercontent.com/75058239/209419137-38b430c0-77a6-4986-8d57-46dc826a3b94.jpg)

- RFC 2277과 2130에서 정의된 **Coded Character Set**은 정수를 글자로 대응시킴
- Coded Character Set은 보통 코드 번호로 인덱싱된 배열로 구현됨
  - 다차원 배열인 경우 코드 번호를 이루는 bit의 덩어리들이 각 축에 대한 색인이 됨
- 역사적으로 중요한 몇 가지 주요 Coded Character Set 표준을 살펴볼 것

**_US-ASCII: 모든 문자집합의 어머니_**

- 1968년 ANSI 표준 X3.4 'American Standard Code for Information Interchange'(정보 교환을 위한 미국 표준 코드)
- code width 전체를 표현하는데 7 bit만을 사용
- 이 문자집합의 다른 국제 변종과 구분짓기 위해, 'US-ASCII'라는 이름이 더 선호됨
- HTTP 메시지는 US-ASCII 사용

**_iso-8859_**

- 국제적인 글쓰기를 위해 필요한 글자들을 high bit를 이용해서 추가한, US-ASCII의 8 bit 확대집합
- 모든 유럽 글자(아시아 글자는 말할 것도 없고)를 담기에는 충분히 크지 않으므로 지역에 따라 커스터마이징 제공
  - iso-8859-1: 서유럽어(영어, 프랑스어)
  - iso-8859-2: 중앙 및 동유럽어(체코어, 폴란드어)
  - iso-8859-3: 남유럽어
  - iso-8859-4: 북유럽어
  - iso-8859-5: 키릴(불가리아어, 러시아어, 세르비아어)
  - iso-8859-6: 아랍어
  - iso-8859-7: 그리스어
  - iso-8859-8: 히브리어
  - iso-8859-9: 터키어
  - iso-8859-10: 노르딕어(아이슬랜드어, 이뉴잇어)
  - iso-8859-15: 새로운 유로 통화 문자를 포함하기 위한 iso-8859-1의 변형
- Latin1로도 알려진 iso-8859-1은 HTML을 위한 기본 문자집합
  - 대부분의 유럽어 텍스트를 표현하기 위해 사용될 수 있음
  - iso-8859-15를 기본 문자집합으로 정하자는 논의가 있었지만, 이미 iso-8859-1이 널리 받아들여져 있으므로 기각
    - 요즘에도 바꾸면 다들 UTF-8로 바꾸기 때문에 iso-8859-15는 더더욱 사용되지 않고 있음

**_JIS X 0201_**

- ASCII에 일본어 가타카나 반각문자를 확장한 문자집합
- 가타카나 반각문자는 본래 일본의 전신 체계에서 쓰이던 것
- 'JIS Roman'으로도 불림
- JIS는 'Japanese Industrial Standard'의 줄임말

**_JIS X 0208, JIS X 0212_**

- 일본어는 여러 문자 체계로부터 온 수천 개의 글자를 담고 있음
  - JIS X 0201의 63개 표음 가타카나 문자로 고통스럽게나마 사용이 가능하긴 하지만,<br>실질적인 사용을 위해서는 완전한 문자집합이 필요
- JIS X 0208: 최초의 multi byte 일본어 문자집합
  - 대부분이 일본식 한자로 되어 있는 6,879개의 코딩된 문자 정의
- JIS X 0212: JIS X 0208에 6,607개의 문자 추가

**_UCS_**

- UCS(Universal Character Set)는 전 세계 모든 글자를 하나의 Coded Character Set으로 통합하고자 노력하는 세계적 표준
- ISO 10646으로 정의됨
- **Unicode**는 UCS 표준을 따르는 상업적 컨소시엄
- UCS 기본 집합은 단 50,000 글자만으로 이루어져 있지만 수백만 개의 글자를 위한 coding space를 갖고 있음

### 3.6 문자 인코딩 구조

- 숫자로 된 문자 코드를 컨텐츠 bit들로 변환하는 디코딩을 하거나, 다시 문자 코드로 인코딩하는 구조

※ 문자 인코딩의 종류들

**고정폭**

- 고정폭 인코딩은 각 코딩된 문자를 고정된 길이의 bit로 표현
- 빠르게 처리 가능하지만 공간 낭비의 우려가 있음

**가변폭(non-modal)**

- 가변폭 인코딩은 다른 문자 코드 번호에 다른 길이의 bit 사용
- 자주 사용하는 글자의 bit 길이를 줄일 수 있고,<br>국제 문자에 대해 여러 byte를 사용하게 해서 8 bit 문자집합과의 호환성도 유지 가능

**가변폭(modal)**

- 모달 인코딩은 서로 다른 모드로의 전환을 위해 특별한 'escape' 패턴 사용
- 처리하기에 복잡하지만, 복잡한 표기 체계를 효과적으로 지원해줄 수 있음

※ 대표적인 인코딩 구조들

**8 bit**

- 고정폭 인코딩 방식으로, 각 문자 코드를 그에 대응하는 8 bit 값으로 인코딩
- 256개 문자의 코드 범위에 대한 문자집합만을 지원
- iso-8859 시리즈가 대표적

**UTF-8**

UCS Transformation Format

- UCS를 위해 설계된 문자 인코딩 구조
- 문자 코드의 값을 위해 non-modal 가변길이 인코딩 사용
- 규칙
  - 첫번째 byte의 앞쪽 bit들은 인코딩된 문자의 길이를 byte 단위로 나타냄
  - 그 이후 byte들은 각각 6 bit의 코드 값을 담음

| 문자 코드 bit | 첫 byte  | 둘째 byte | 셋째 byte | 넷째 byte | 다섯째 byte | 여섯째 byte |
| :-----------: | :------: | :-------: | :-------: | :-------: | :---------: | :---------: |
|      0-7      | 0xxxxxxx |           |           |           |             |             |
|     8-11      | 110xxxxx | 10xxxxxx  |           |           |             |             |
|     12-16     | 1110xxxx | 10xxxxxx  | 10xxxxxx  |           |             |             |
|     17-21     | 11110xxx | 10xxxxxx  | 10xxxxxx  | 10xxxxxx  |             |             |
|     22-26     | 111110xx | 10xxxxxx  | 10xxxxxx  | 10xxxxxx  |  10xxxxxx   |             |
|     27-31     | 1111110x | 10xxxxxx  | 10xxxxxx  | 10xxxxxx  |  10xxxxxx   |  10xxxxxx   |

- 만약 첫 번째 인코딩된 byte의 (가장 앞쪽에 있는)high bit가 0이라면, 길이는 1byte
  - 이 덕에 ASCII와의 호환성을 완벽하게 확보함
  - 하지만 iso-8859 시리즈와는 호환이 안됨 (그들은 8bit를 써야 하기 때문에)
- 예시
  - 문자 코드 90(ASCII 'Z') → 01011010
  - 문자 코드 5073 → 11100001 10001111 10010001

**iso-2022-jp**

- 일본어 인터넷 문서를 위해 널리 사용되는 인코딩
- 8 bit 문자를 지원하지 않는 소프트웨어와의 문제를 방지하기 위해 128보다 작은 값으로 이루어진 가변길이 모달 인코딩
- encoding context는 4가지의 미리 정의된 문자집합 중 하나로 설정됨
  - iso-2022-jp 인코딩은 이 4가지의 문자집합에 강하게 결합되어 있으며,<br>이는 다른 인코딩들이 특정 문자집합에 대해 독립적이라는 점과 대조됨
  - 특별한 3 byte의 'escape 문자열'은 집합 간의 전환을 할 수 있게 해줌
  - US-ASCII, JIS-Roman, JIS X 0208-1978, JIS X 0208-1983 간의 전환 가능

| escape 문자열 | 전환 후 문자집합 | 코드당 byte 수 |
| :-----------: | :--------------: | :------------: |
|    ESC ( B    |     US-ASCII     |       1        |
|    ESC ( J    |    JIS-Roman     |       1        |
|    ESC $ @    | JIS X 0208-1978  |       2        |
|    ESC $ B    | JIS X 0208-1983  |       2        |

- 일본어 텍스트는 escape 문자열과 함께 끝나야 함
- JIS X 0208 문자집합을 사용할 때 각 byte의범위는 33 ~ 126으로 제한됨

**euc-jp**

- 또 하나의 인기 있는 일본어 인코딩
- EUC: Extended Unix Code
- iso-2022-jp와 비슷하게, 여러 표준 일본어 문자집합을 사용할 수 있게 해주는 가변길이 인코딩
  - 대신 _non-modal_
  - escape 문자열이 존재하지 않음
- 반각 가타카나, JIS X 0201, JIS X 0208, JIS X 0212 총 4가지의 Coded Character Set 지원
  - 1 byte 사용: JIS Roman
  - 2 byte 사용: 반각 가타카나, JIS X 0208
  - 3 byte 사용: JIS X 0212
- 이 코딩은 다소 공간을 낭비하긴 하지만 처리가 단순

**euc-kr**

- 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩
- KS X 1003, KS X 1001 2가지 문자집합 지원
  - KS X 1003: 1 byte로 인코딩되는 로마자 문자 집합
    - 사실상 US-ASCII에서 `\`를 `₩`로 치환하기만 한 것
  - KS X 1001: 2 byte로 인코딩되는 한글, 한자, 특수문자 등으로 이루어진 한국어 문자집합
- KS X 1001이 담고 있는 한글 총 2,350자는 턱없이 부족한 숫자
  - 그래서 한글 채움 문자(fill code, 0xA4 0xD4)를 사용해서 한글을 표현하는 방식 규정
    - 한글 문자 한 개를 '(채움) 초성 중성 종성'으로 표현
    - 예시) '똠' → '(채움) ㄸ ㅗ ㅁ'
